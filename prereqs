#! /usr/bin/env bash

PREREQS=$(basename "$0")

has_awk() {
    # Note: We use `awk` because its behavior is more consistent across
    # platforms than `sed` (To use ERE with sed in BSDs is -E whereas in GNU is -r)
    # If we find that `awk` is not reliably available, we can switch to
    # `sed` with capability tests to determine the correct ERE flag.
    awk 2> /dev/null
    if [[ $? != 1 ]]; then
        echo "awk not found"
        return 1
    fi
    return 0
}

# Returns the physical dir that this script is in.
# To use:
# local prereqs_dir_retval
# prereqs_dir
# echo $prereqs_dir_retval
prereqs_dir() {
    local d=""
    local src="${BASH_SOURCE[0]}"
    # # resolve $src until the file is no longer a symlink.
    while [[ -h "$src" ]]; do
        d="$(cd -P "$(dirname "$src")" && pwd)"
        src="$(readlink "$src")"
        # If src was a relative symlink, we need to resolve it relative to
        # the path where the symlink was located.
        [[ $src != /* ]] && src="$d/$src"
    done
    prereqs_dir_retval="$(cd -P "$(dirname "$src")" && pwd)"
    return 0
}

has() {
    local tool=$1
    if [[ ! -z $(type -p "${tool}") ]]; then
        echo "${tool} exists."
        return 0
    else
        echo "WARNING: ${tool} not found."
        prereqs_found=false
        return 1
    fi
}

prereqs_check() {
    prereqs_found=true
    local config_file=${1}
    if [[ -z ${config_file} ]]; then
        # Get prereqs from README
        # TODO: Currently checks for `README.md`; also look for `README`?
        # TODO: Currently checks for README.md in local directory

        # Find most-indented prereqs section
        declare -a header_tags=('######' '#####' '####' '###' '##' '#')
        for header_tag in ${header_tags[@]}; do
            local line_number=$(awk "/${header_tag} prereqs$|${header_tag} prerequisites$/{print NR}" README.md)
            if [[ ! -z ${line_number} ]]; then
                break
            fi
        done
        # echo "Found prereqs section on line $line_number with indentation $header_tag"

        # Scan until next header section
        while [[ ${line_number} -lt $(awk 'END {print NR}' README.md) ]] ; do
            line_number=$((line_number + 1))
            local line=$(awk "NR==${line_number}" README.md)
            if [[ ! -z $(echo $line | awk "/##/") ]]; then
                break
            fi

            local prereq=$(echo $line | sed "s/- //")
            prereq=$(echo ${prereq} | sed 's/^[[:space:]]*//g')
            # TODO: support descriptions ala "Postgres (psql)"
            if [[ ! -z ${prereq} ]]; then
                set +e
                has ${prereq}
                if [[ $? != 0 ]]; then
                    prereqs_found="false"
                fi
                set -e
            fi
        done

    else
        # Get prereqs from config file
        set +e
        # shellcheck source=/dev/null
        . "${config_file}"
        set -e
    fi
    if [[ $prereqs_found == "true" ]]; then
        echo "OK: all prereqs found"
    else
        echo "ERROR: some prereqs missing, please install them"
        return 1
    fi
}

prereqs_update() {
    local tag=${1:-latest}
    local d=""
    local prereqs_dir_retval
    if prereqs_dir; then
        d="$prereqs_dir_retval"
    else
        # error
        return 1
    fi
    if ! has curl; then
        return 1
    fi
    pushd "$d" > /dev/null
    local prereqs_tmp="${PREREQS}.tmp"
    if curl -s -q -o "$prereqs_tmp" \
            "https://raw.githubusercontent.com/trussworks/prereqs/${tag}/prereqs"
    then
        echo "Got it"
        install -C "${prereqs_tmp}" "${PREREQS}"
    else
        echo "Failed"
        return 1
    fi
}

prereqs_usage() {
    cat <<EOF
Usage: ${PREREQS} [-f prereq.conf] [-h] [-u [-t tag]]

       -f         Specify a file to check for prereqs. Defaults to parsing README.md
       -h         Print this help
       -u         Update prereq to current version from tag (default latest)
       -t         Tag to update to (default latest)
EOF
}

main() {
    # Check for awk
    has_awk
    has_awk_ret=$?
    if [[ ${has_awk_ret} != 0 ]]; then
        return ${has_awk_ret}
    fi

    # Enable the safeties
    set -eu -o pipefail
    local update_tag="latest"
    while getopts 'f:hut:' opt; do
        case ${opt} in
            f)
                prereqs_check "${OPTARG}"
                exit $?
                ;;
            h)
                prereqs_usage
                exit 0
                ;;
            u)
                prereqs_update "${update_tag}"
                exit $?
                ;;
            t)
                update_tag="${OPTARG}"
                ;;
            *)
                prereqs_usage
                exit 1
                ;;
        esac
    done
    prereqs_check
    exit $?
}

# Execute main() if this is run in standalone mode (vs. from a unit test)
[ -z "${SHUNIT_VERSION}" ] && main "$@"
